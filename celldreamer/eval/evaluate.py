from celldreamer.eval.optimal_transport import wasserstein
import scanpy as sc

def scanpy_pipeline(adata):
    """
    Preprocesses an AnnData object using Scanpy's preprocessing pipeline.

    Parameters:
        adata (AnnData): Annotated Data object.

    Returns:
        AnnData: Processed AnnData object.
    """
    sc.pp.log1p(adata)
    sc.pp.neighbors(adata)
    sc.tl.pca(adata)
    sc.tl.umap(adata)
    return adata

def plot_and_save_umap(adata, plotting_folder):
    """
    Plots and saves the UMAP (Uniform Manifold Approximation and Projection) of an AnnData object.

    Parameters:
        adata (AnnData): Annotated Data object.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.
    """
    sc.settings.figdir = str(plotting_folder)
    sc.pl.umap(adata, show=False, save="generated_umap.png")

def compute_generated_umap(model, 
                            batch_size, 
                            n_sample_steps, 
                            clip_samples, 
                            library_size, 
                            plotting_folder):
    """
    Generates UMAP plot for samples generated by a given model.

    Parameters:
        model: The generative model.
        batch_size (int): Number of samples to generate.
        n_sample_steps (int): Number of steps for sampling.
        clip_samples (bool): Whether to clip generated samples.
        library_size (float): Size of the generated library.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.

    Returns:
        AnnData: Annotated Data object containing the generated samples with UMAP coordinates.
    """
    X_generated = model.sample(batch_size, n_sample_steps, clip_samples, library_size)
    adata_generated = sc.AnnData(X=X_generated.cpu().numpy())
    adata_generated = scanpy_pipeline(adata_generated)
    plot_and_save_umap(adata_generated, plotting_folder)
    return adata_generated

def compute_real_fake_wasserstein(model, 
                                  X_real,
                                  batch_size, 
                                  n_sample_steps, 
                                  clip_samples, 
                                  library_size):
    """
    Computes the Wasserstein distance between real and generated samples and returns the result.

    Parameters:
        model: The generative model.
        X_real (numpy.ndarray): Real samples for comparison.
        batch_size (int): Number of samples to generate.
        n_sample_steps (int): Number of steps for sampling.
        clip_samples (bool): Whether to clip generated samples.
        library_size (float): Size of the generated library.

    Returns:
        float: Wasserstein distance between real and generated samples.
    """
    X_generated = model.sample(batch_size, n_sample_steps, clip_samples, library_size)
    return wasserstein(X_real, X_generated)
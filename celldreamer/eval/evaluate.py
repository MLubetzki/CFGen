import pandas as pd
import numpy as np
from celldreamer.eval.distribution_distances import compute_distribution_distances
import scanpy as sc

def scanpy_pipeline(adata):
    """
    Preprocess an AnnData object using Scanpy's preprocessing pipeline.

    Args:
        adata (AnnData): Annotated Data object.

    Returns:
        AnnData: Processed AnnData object with PCA and UMAP computed.
    """
    # Perform PCA
    sc.tl.pca(adata)
    # Compute the neighborhood graph
    sc.pp.neighbors(adata)
    # Compute UMAP
    sc.tl.umap(adata)
    return adata

def plot_and_save_umap(adata, plotting_folder, epoch, real_and_fake_dataset=False):
    """
    Plot and save the UMAP (Uniform Manifold Approximation and Projection) of an AnnData object.

    Args:
        adata (AnnData): Annotated Data object.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.
        epoch (int): The epoch number used for naming the saved plots.
        real_and_fake_dataset (bool, optional): Whether the dataset contains both real and fake data. Default is False.
    """
    # Set the plotting directory
    sc.settings.figdir = str(plotting_folder)
    if not real_and_fake_dataset:
        sc.pl.pca(adata, show=False, save=f"generated_pca_{epoch}.png")
        sc.pl.umap(adata, show=False, save=f"generated_umap_{epoch}.png")
    else:
        sc.pl.pca(adata, color="dataset_type", show=False, save=f"generated_pca_real_fake_{epoch}.png")
        sc.pl.umap(adata, color="dataset_type", show=False, save=f"generated_umap_real_fake_{epoch}.png")

def compute_umap_and_wasserstein(model, 
                                 batch_size, 
                                 n_sample_steps, 
                                 plotting_folder, 
                                 X_real, 
                                 epoch,
                                 theta_covariate,
                                 size_factor_covariate):
    """
    Generate UMAP plot for samples generated by a given model and compute Wasserstein distances.

    Args:
        model: The generative model.
        batch_size (int): Number of samples to generate.
        n_sample_steps (int): Number of steps for sampling.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.
        X_real (torch.Tensor): Tensor containing concatenated test data.
        epoch (int): The epoch number used for naming the saved plots.
        theta_covariate: Covariate used for theta.
        size_factor_covariate: Covariate used for size factor.

    Returns:
        dict: Dictionary containing Wasserstein distances for each modality.
    """
    # Determine the modalities based on the model
    if not model.multimodal:
        modality_list = ["rna"]
    else:
        modality_list = model.modality_list

    # Sample batches
    repetitions = batch_size // 100
    X_generated_dict = model.batched_sample(100, 
                                            repetitions,
                                            n_sample_steps, 
                                            theta_covariate,
                                            size_factor_covariate, 
                                            conditioning_covariates=model.covariate_list)
    
    # Ensure the generated data is in dictionary format
    if len(modality_list) == 1:
        X_generated_dict = {"rna": X_generated_dict}
        X_real = {"rna": X_real}
    
    # Initialize a dictionary to store Wasserstein distances
    wd = {}
    for mod in modality_list:
        # Convert generated data to CPU
        X_generated = X_generated_dict[mod].cpu()
        
        # Compute Wasserstein distances
        wd_mod = compute_distribution_distances(X_generated, X_real[mod])
        wd_mod = {f"{key}_{mod}": val for key, val in wd_mod.items()}
        wd.update(wd_mod)
        
        # Compute and plot UMAP of generated data
        X_generated = X_generated.numpy()
        adata_generated = sc.AnnData(X=X_generated.copy())
        adata_generated = scanpy_pipeline(adata_generated)
        plot_and_save_umap(adata_generated, plotting_folder / mod, epoch, real_and_fake_dataset=False)
        
        # Combine real and generated data for comparison
        X = np.concatenate([X_generated, X_real[mod].numpy()], axis=0)
        annot = ["generated"] * len(X_generated) + ["real"] * len(X_real[mod])
        annot_df = pd.DataFrame({"dataset_type": annot})
        adata_real_fake = sc.AnnData(X=X, obs=annot_df)
        adata_real_fake = scanpy_pipeline(adata_real_fake)
        plot_and_save_umap(adata_real_fake, plotting_folder / mod, epoch, real_and_fake_dataset=True)
    
    return wd


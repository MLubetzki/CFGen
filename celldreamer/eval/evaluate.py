import pandas as pd
import numpy as np
from celldreamer.eval.optimal_transport import wasserstein
import scanpy as sc

def scanpy_pipeline(adata):
    """
    Preprocesses an AnnData object using Scanpy's preprocessing pipeline.

    Parameters:
        adata (AnnData): Annotated Data object.

    Returns:
        AnnData: Processed AnnData object.
    """
    sc.pp.log1p(adata)
    sc.tl.pca(adata)
    sc.pp.neighbors(adata)
    sc.tl.umap(adata)
    return adata

def plot_and_save_umap(adata, plotting_folder, real_and_fake_dataset=False):
    """
    Plots and saves the UMAP (Uniform Manifold Approximation and Projection) of an AnnData object.

    Parameters:
        adata (AnnData): Annotated Data object.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.
    """
    # Set the plotting directory
    sc.settings.figdir = str(plotting_folder)
    if not real_and_fake_dataset:
        sc.pl.umap(adata, show=False, save="generated_umap.png")
    else:
        sc.pl.umap(adata, color="dataset_type", show=False, save="generated_umap_real_fake.png")

def compute_umap_and_wasserstein(model, 
                                    batch_size, 
                                    n_sample_steps, 
                                    clip_samples, 
                                    plotting_folder, 
                                    X_real, 
                                    sampling_covariate):
    """
    Generates UMAP plot for samples generated by a given model.

    Parameters:
        model: The generative model.
        batch_size (int): Number of samples to generate.
        n_sample_steps (int): Number of steps for sampling.
        clip_samples (bool): Whether to clip generated samples.
        library_size (float): Size of the generated library.
        plotting_folder (str): Path to the folder where the UMAP plot should be saved.
        X_real (torch.Tensor): tensor containing concatenated test data. 

    Returns:
        AnnData: Annotated Data object containing the generated samples with UMAP coordinates.
    """
    # Generate data and compute Wasserstein distance from test data
    X_generated = model.sample(batch_size, n_sample_steps, clip_samples, covariate=sampling_covariate)
    wd = wasserstein(X_real, X_generated)
    # Compute and plot UMAP of generated data
    X_generated = X_generated.cpu().numpy()
    adata_generated = sc.AnnData(X=X_generated.copy())
    adata_generated = scanpy_pipeline(adata_generated)
    plot_and_save_umap(adata_generated, plotting_folder, real_and_fake_dataset=False)
    
    # Process the real data, take logarithm and compute UMAP 
    X = np.concatenate([X_generated, 
                        X_real.cpu().numpy()], axis=0) 
    annot = ["generated" for _ in range(len(X_generated))]+["real" for _ in range(len(X_real))]
    annot_df = pd.DataFrame({"dataset_type": annot})
    adata_real_fake = sc.AnnData(X=X, obs=annot_df)
    adata_real_fake = scanpy_pipeline(adata_real_fake)
    plot_and_save_umap(adata_real_fake, plotting_folder, real_and_fake_dataset=True)    
    return wd
